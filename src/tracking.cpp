/********************************************************************

Vrui_mdf/tracking - Node to read the tracking and buttons status from
a VR Device, plug the data into messages with a specific formate and
publush the message on a specific topic.

The codes here to read the tracking data are from Vrui/DeviceTest, which
is a sample program of the Virtual Reality User Interface Library(Vrui),

Current it only publishes to update the state for headset and left
controller models in Gazebo. - 03/19/2018

---

LICENSE INFORMATION:

This file was generated by code written by Zhenyu Shi, a member of the
AS4SR Lab at the University of Cincinnati.

The source code used to generate this file, and the code snippets in
the github.com/zhenyushi/Vrui_mdf repository included in this file are
released under a BSD 3-clause license:

Copyright 2018 University of Cincinnati
All rights reserved. See LICENSE file at:
https://github.com/zhenyushi/Vrui_mdf
Additional copyright is held by others, as reflected in the commit
history and as listed below.

The code snippets from the Vrui 4.5-001 library included in this file are
released under a GPL license, see below (in the "DeviceTest" section):

/***********************************************************************
DeviceTest - Program to test the connection to a Vrui VR Device Daemon
and to dump device positions/orientations and button states.
Copyright (c) 2002-2016 Oliver Kreylos

This file is part of the Virtual Reality User Interface Library (Vrui).

The Virtual Reality User Interface Library is free software; you can
redistribute it and/or modify it under the terms of the GNU General
Public License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

The Virtual Reality User Interface Library is distributed in the hope
that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with the Virtual Reality User Interface Library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA
***********************************************************************/
/*

The code sections that came from Vrui/Vrui-4.5-001/Vrui/Utilities/DeviceTest.cpp are the following:
-- lines 177 - 201 (codes to Initialize device client)
-- lines 235 - 286 (function to read tracking data from Vive headset)

***********************************************************************/

/*
GENERATED CODE STARTS HERE:
*/

/* header files used in Vrui/DeviceTest */
/* file path needs to be define in CMakeLists.txt*/
#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <iomanip>
#include <stdexcept>

#include <Misc/FunctionCalls.h>
#include <Misc/ConfigurationFile.h>
#include <Realtime/Time.h>
#include <Geometry/AffineCombiner.h>

#include <Vrui/Internal/VRDeviceDescriptor.h>
#include <Vrui/Internal/HMDConfiguration.h>
#include <Vrui/Internal/VRDeviceClient.h>

/*
Vrui is built by a script, some of the classes and functions are
defined in .cpp or .icpp files, to import Vrui into ros package,
those files also need to be included. This vrui_mdf.h includes
all extra files that are needed.
*/
#include "vrui_mdf.h"

/* ros header files for model state publishing in Gazebo, added for Gazebo application */
#include <ros/ros.h>
#include <gazebo_msgs/ModelState.h>
#include <tf/transform_broadcaster.h>// translation between Eular angle and Quaternion, unnecessary for tracking since Quaternion can be received directly

#include "tf/transform_datatypes.h"
#include <geometry_msgs/Quaternion.h>
#include <cmath>
#include <math.h>
#include<fstream>
#include <vrui_mdf/Vive.h>

#include <geometry_msgs/Twist.h>
#include <gazebo_msgs/SetModelState.h>
#include "gazebo_msgs/GetModelState.h"
#include "gazebo_msgs/DeleteModel.h"
#include "gazebo_msgs/SpawnModel.h"


/* VIVE tracking data reading definitions, come directly from Vrui/DeviceTest */
typedef Vrui::VRDeviceState::TrackerState TrackerState;
typedef TrackerState::PositionOrientation PositionOrientation;
typedef PositionOrientation::Scalar Scalar;
typedef PositionOrientation::Point Point;
typedef PositionOrientation::Vector Vector;
typedef PositionOrientation::Rotation Rotation;


/* VIVE headset configuration reading definitions, come directly from Vrui/DeviceTest */
unsigned int numHmdConfigurations=0;
const Vrui::HMDConfiguration** hmdConfigurations=0;
unsigned int* eyePosVersions=0;
unsigned int* eyeVersions=0;
unsigned int* distortionMeshVersions=0;


/* main function, VIVE tracking parts are from Vrui/DeviceTest directly */

/***********************************************************************

The main thread here is to read position and orientation data from headset
and controllers, and publish it to the VR camera model in gazebo.

Originally, Vrui/DeviceTest has many different tracking and printing modes,
so it"s a very good sample to understand how Vrui works.

For this Gazebo application, codes for Vrui/DeviceTest are refered,
and unnecessary printing modes for this application are removed.

***********************************************************************/

int main(int argc,char* argv[])
{
     
     /* Set up ros node and define publisher for gazebo */
     ros::init(argc, argv, "camera_state");
     ros::NodeHandle n;
     ros::Rate r(90);
     ros::service::waitForService("/gazebo/spawn_urdf_model", -1);
     /* gazebo model state publisher and topic */
     ros::Publisher gazebo_pub = n.advertise<gazebo_msgs::ModelState>("gazebo/set_model_state", 10);
     gazebo_msgs::ModelState camera;
     camera.model_name = "vr_view";
     camera.reference_frame="world";
     
     vrui_mdf::Vive vive;
     vive.user_name = "vive";
     ros::Publisher vive_state = n.advertise<vrui_mdf::Vive>("vrui/vive", 10);
     
     /********************************************************************/
     /* Vrui/DeviceTest code starts (order and detail might be modified) */
     
     /* Parse command line: (original commitment)*/
     char* serverName=0;//necessary, but usually fixed if only one headset are used
     int trackerIndex=0;//index for headset
     int trackerIndex_left=1;//index for left controller
     int trackerIndex_right=2;//index for right controller
     
     
     bool printButtonStates=false;//switch for printing button in terminal, unnecessary for gazebo
     
     
     int portNumber=8555;//portnumber come from input in original Vrui/DeviceTest code, usually fixed if only one headset are used
     
     
     /* Initialize device client: (original commitment)*/
     Vrui::VRDeviceClient* deviceClient=0;
     
     /* a while loop can be used to replace this try, so that the code will wait for RunViveTracker.sh while using roslaunch (original commitment)*/
     try
     {
     deviceClient=new Vrui::VRDeviceClient(serverName,portNumber);
     }
     catch(std::runtime_error error)
     {
     std::cerr<<"Caught exception "<<error.what()<<" while initializing VR device client"<<std::endl;
     return 1;
     }
     
     
     /* Run main loop: (original commitment)*/
     Misc::Timer t;
     int numPackets=0;
     try
     {
          deviceClient->activate();
          deviceClient->startStream(0);
          
          bool loop=true;
          bool oldTriggerState=false;
          
          gazebo_msgs::SpawnModel sm;
          ros::ServiceClient spawn_model;
          spawn_model = n.serviceClient<gazebo_msgs::SpawnModel>("/gazebo/spawn_sdf_model");
          std::ifstream ifs,ifs1;
          ifs.open("/home/zhenyushi/.gazebo/models/controller/model.sdf");
          std::stringstream stringstream;
          stringstream << ifs.rdbuf();
          sm.request.model_name = "base_test";
          sm.request.model_xml = stringstream.str();
          sm.request.robot_namespace = ros::this_node::getNamespace();
          sm.request.reference_frame = "world";
          spawn_model.call(sm);
          
          ifs1.open("/home/zhenyushi/.gazebo/models/vr_view/model.sdf");
          std::stringstream stringstream1;
          stringstream1 << ifs1.rdbuf();
          sm.request.model_name = "vr_view";
          sm.request.model_xml = stringstream1.str();
          sm.request.robot_namespace = ros::this_node::getNamespace();
          sm.request.reference_frame = "world";
          spawn_model.call(sm);
          
          ros::ServiceClient client_set = n.serviceClient<gazebo_msgs::SetModelState>("/gazebo/set_model_state");
          gazebo_msgs::SetModelState Setmodelstate;
          
          Setmodelstate.request.model_state.model_name = "base_test";
          Setmodelstate.request.model_state.reference_frame="world";
          Setmodelstate.request.model_state.pose.position.x = 0;
          Setmodelstate.request.model_state.pose.position.y = 0;
          Setmodelstate.request.model_state.pose.position.z = 0;
          
          Setmodelstate.request.model_state.pose.orientation.x = 0;
          Setmodelstate.request.model_state.pose.orientation.y = 0;
          Setmodelstate.request.model_state.pose.orientation.z = 0;
          Setmodelstate.request.model_state.pose.orientation.w = 1;
          client_set.call(Setmodelstate);
          
          
          //std::cout<<Setmodelstate.request<<std::endl;
          ros::ServiceClient client = n.serviceClient<gazebo_msgs::GetModelState>("/gazebo/get_model_state");
          gazebo_msgs::GetModelState getmodelstate;
          /*
          getmodelstate.request.model_name = "base_test";
          client.call(getmodelstate);
          std::cout<<getmodelstate.response<<std::endl;
          */
          system("rosrun gazebo_ros spawn_model -file $(find vrui_mdf)/models/vr_view/model.sdf -sdf -model vr_view -y 0 -x 0 -z 1");
          system("rosrun gazebo_ros spawn_model -file $(find vrui_mdf)/models/controller/model.sdf -sdf -model base_test -y 0 -x 0 -z 0");
          while(ros::ok())
          {
               /* Get packet timestamp: (original commitment)*/
               Realtime::TimePointMonotonic now;
               Vrui::VRDeviceState::TimeStamp nowTs=Vrui::VRDeviceState::TimeStamp(now.tv_sec*1000000+(now.tv_nsec+500)/1000);
               ++numPackets;
               
               deviceClient->lockState();//devices state needs to be locked before read
               const Vrui::VRDeviceState& state=deviceClient->getState();
               
               
               /* read state of headset, trackerIndex=0 */
               const TrackerState& ts=state.getTrackerState(trackerIndex);
               Point pos=ts.positionOrientation.getOrigin();
               Rotation rot=ts.positionOrientation.getRotation();
               const float* quaternion;
               quaternion=rot.getQuaternion();
               /* Eular angle representation is used in original Vrui/DeviceTest code,
               getQuaternion() is defined in header files and works better for ros publishers */
               
               
               /* read state of left controller, trackerIndex=1
               extra chunks are added to track headset and controllers in the same cycle
               controllers are symmetric and identical, left and right can be defined in downstream codes  */
               const TrackerState& ts_left=state.getTrackerState(trackerIndex_left);
               Point pos_left=ts_left.positionOrientation.getOrigin();
               Rotation rot_left=ts_left.positionOrientation.getRotation();
               const float* quaternion_left;
               quaternion_left=rot_left.getQuaternion();
               
               /* read state of right controller, trackerIndex=2 */
               const TrackerState& ts_right=state.getTrackerState(trackerIndex_right);
               Point pos_right=ts_right.positionOrientation.getOrigin();
               Rotation rot_right=ts_right.positionOrientation.getRotation();
               const float* quaternion_right;
               quaternion_right=rot_right.getQuaternion();
               
               
               /* Vrui/DeviceTest code ends */
               /*****************************/
               
               // headset bias, roomsetup will be further tested
               float bias_0 = -0.191;
               float bias_1 = 2.2;
               float bias_2 = 1.98;
               
               getmodelstate.request.model_name = "base_test";
               client.call(getmodelstate);
               //std::cout<<getmodelstate.response<<std::endl;
               
               // plug in the data to message and publish it to gazebo
               // coordinate in VIVE is different from gazebo, rotation matrix from VIVE to Gazebo is R = [0,0,-1; -1,0,0; 0,1,0]
               camera.pose.position.x = -1*pos[2] - bias_2 + getmodelstate.response.pose.position.x;
               camera.pose.position.y = -1*pos[0] - bias_0 + getmodelstate.response.pose.position.y;
               camera.pose.position.z = pos[1] + bias_1 + getmodelstate.response.pose.position.z;
               
               camera.pose.orientation.x = -1*quaternion[2];
               camera.pose.orientation.y = -1*quaternion[0];
               camera.pose.orientation.z = quaternion[1];
               camera.pose.orientation.w = quaternion[3];
               
               gazebo_pub.publish(camera);
               
               /* Custom message for ROS controller */
               /* headset */
               vive.headset = camera.pose;
               
               /* left controller */
               vive.ctrl_left.pose.position.x = -1*pos_left[2] - bias_2 + getmodelstate.response.pose.position.x;
               vive.ctrl_left.pose.position.y = -1*pos_left[0] - bias_0 + getmodelstate.response.pose.position.y;
               vive.ctrl_left.pose.position.z = pos_left[1] + bias_1 + getmodelstate.response.pose.position.z;
               
               vive.ctrl_left.pose.orientation.x = -1*quaternion_left[2];
               vive.ctrl_left.pose.orientation.y = -1*quaternion_left[0];
               vive.ctrl_left.pose.orientation.z = quaternion_left[1];
               vive.ctrl_left.pose.orientation.w = quaternion_left[3];
               
               vive.ctrl_left.buttons.system = state.getButtonState(2);
               vive.ctrl_left.buttons.grip = state.getButtonState(3);
               vive.ctrl_left.buttons.menu = state.getButtonState(4);
               vive.ctrl_left.buttons.trigger = state.getButtonState(5);
               vive.ctrl_left.buttons.trackpad = state.getButtonState(6);
               
               /* trackpad touching data not available yet */
               //vive.ctrl_left.trackpad.x = ;
               //vive.ctrl_left.trackpad.y = ;
               
               /* right controller */
               vive.ctrl_right.pose.position.x = -1*pos_right[2] - bias_2 + getmodelstate.response.pose.position.x;
               vive.ctrl_right.pose.position.y = -1*pos_right[0] - bias_0 + getmodelstate.response.pose.position.y;
               vive.ctrl_right.pose.position.z = pos_right[1] + bias_1 + getmodelstate.response.pose.position.z;
               
               vive.ctrl_right.pose.orientation.x = -1*quaternion_right[2];
               vive.ctrl_right.pose.orientation.y = -1*quaternion_right[0];
               vive.ctrl_right.pose.orientation.z = quaternion_right[1];
               vive.ctrl_right.pose.orientation.w = quaternion_right[3];
               
               vive.ctrl_right.buttons.system = state.getButtonState(8);
               vive.ctrl_right.buttons.grip = state.getButtonState(9);
               vive.ctrl_right.buttons.menu = state.getButtonState(10);
               vive.ctrl_right.buttons.trigger = state.getButtonState(11);
               vive.ctrl_right.buttons.trackpad = state.getButtonState(12);
               
               /* trackpad touching data not available yet */
               //vive.ctrl_left.trackpad.x = ;
               //vive.ctrl_left.trackpad.y = ;
               
               vive_state.publish(vive);
               
               
               /******************************************/
               /* following code is from Vrui/DeviceTest */
               deviceClient->unlockState();//devices state needs to be unlocked after read
               
               
               
               /* Check for a key press event: (original commitment)*/
               fd_set readFdSet;
               FD_ZERO(&readFdSet);
               FD_SET(fileno(stdin),&readFdSet);
               struct timeval timeout;
               timeout.tv_sec=0;
               timeout.tv_usec=0;
               bool dataWaiting=select(fileno(stdin)+1,&readFdSet,0,0,&timeout)>=0&&FD_ISSET(fileno(stdin),&readFdSet);
               if(dataWaiting)
               loop=false;
               
               /* Wait for next packet: (original commitment)*/
               deviceClient->getPacket();
               
               r.sleep();// rate control from ros, unnecessary, VIVE packet comes at a rate of 90hz
               
          }//end of while(ros::ok()) loop
          
     }//end of the huge try loop
     catch(std::runtime_error err)
     {
     std::cerr<<"Caught exception "<<err.what()<<" while reading tracking data"<<std::endl;
     }
     
     // After ros is shut down
     t.elapse();//to end (delete the if loop(946-949))
     std::cout<<"Received "<<numPackets<<" device data packets in "<<t.getTime()*1000.0<<" ms ("<<double(numPackets)/t.getTime()<<" packets/s)"<<std::endl;
     deviceClient->stopStream();
     deviceClient->deactivate();
     
     /* Clean up and terminate: (original commitment)*/
     delete[] hmdConfigurations;
     delete[] eyePosVersions;
     delete[] eyeVersions;
     delete[] distortionMeshVersions;
     delete deviceClient;
     return 0;
     
}// end of int main()
